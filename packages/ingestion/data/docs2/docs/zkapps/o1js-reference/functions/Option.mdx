```ts
function Option<A>(type: A): ProvableInferPureFrom<A, Option<InferProvable<A>, InferValue<A>>, InferValue<A> | undefined> & (option: {
  "isSome": Bool;
  "value": InferProvable<A>;
 }) => Option<InferProvable<A>, InferValue<A>> & {
  "from": Option<InferProvable<A>, InferValue<A>>;
  "fromValue": Option<InferProvable<A>, InferValue<A>>;
  "none": Option<InferProvable<A>, InferValue<A>>;
}
```

Define an optional version of a provable type.

## Type parameters

• **A** *extends* [`ProvableType`](../type-aliases/ProvableType.mdx)

## Parameters

• **type**: `A`

## Returns

`ProvableInferPureFrom`\<`A`, [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>, `InferValue`\<`A`\> \| `undefined`\> & (`option`: \{
  `"isSome"`: [`Bool`](../type-aliases/Bool.mdx);
  `"value"`: [`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>;
 \}) => [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\> & \{
  `"from"`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
  `"fromValue"`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
  `"none"`: [`Option`](../type-aliases/Option.mdx)\<[`InferProvable`](../type-aliases/InferProvable.mdx)\<`A`\>, `InferValue`\<`A`\>\>;
 \}

## Example

```ts
class OptionUInt64 extends Option(UInt64) {}

// create an optional UInt64
let some = OptionUInt64.from(5n);
let none = OptionUInt64.none();

// get back a UInt64
let five: UInt64 = some.assertSome('must have a value');
let zero: UInt64 = none.orElse(0n); // specify a default value
```

## Source

[lib/provable/option.ts:37](https://github.com/o1-labs/o1js/blob/6ebbc23710f6de023fea6d83dc93c5a914c571f2/src/lib/provable/option.ts#L37)
